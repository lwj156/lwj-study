# 深入理解Java虚拟机读书笔记

## OOM

> 内存溢出的时候Dump快照
>
>  -XX：+HeapDumpOnOutOf-MemoryError

 

方法区的实现：永久代和元空间都是方法区的实现

1. jdk<=1.6：永久代，常量池位于永久代中
2. jdk>1.6：元空间，常量池子位于堆中



## GC相关

### 判断对象GC条件

1. 引用计数器：循环引用无法回收问题
2. 可达性算法
   - 两次标记：一次查看是否有finalized（）方法需要执行：`逃脱GC的最后机会`，第二次则进行回收

### 对象引用状态

强、软、弱、虚

强：关系存在不回收

软：OOM之前，进行第二次GC

弱：GC时一定回收

虚：回收收到系统通知

### 常见问题

1. 跨代引用回收：新生代与老年代直接的互相引用会导致遍历对象增多。jvm引入`记忆集`，把老年代分成若干小块，Minor GC的跨代引用只扫描包含跨代引用的集合

### 常见概念

1. 分配担保：当Survivor空间不足容纳Minor GC后存活的对象，就依赖老年代进行分配担保，直接进入老年代
2. 如何解决标记-清除的空间碎片：通过内存分配/访问器
3. 可达性算法在`枚举根节点`的时候需要停顿，而在查找引用链过程中不需要停顿
4. 可达性算法过程采用三色标记

### 暂停到GC安全点的方式

1. 抢先式中断：先全部中断
2. 主动式中断：通过标志位到最近安全点中断，参考线程的interrupt

![image-20200819111350738](https://gitee.com/lwj156/picture/raw/master/image/mybatis/image-20200819111350738.png)

使用-XX：+UseConcMarkSweepGC配置指定CMS

- Shenandoah和ZGC 有空可以了解



### HotSpot算法细节

#### 根节点枚举

> GC回收不可能枚举GC Roots（耗时）：存在OopMap对象里面

#### 安全点

安全点的位置：是否具有让程序长时间执行（方法、循环、异常）

**中断方式**：

1. 抢先式中断（很少jvm使用）：把所有用户线程中断，未到安全点的线程在执行一会，到安全点中断。
2. 主动式中断：设置标志位，执行线程不断轮询，一旦到达就刮起。

**安全区域**：

> 主要解决有的线程Sleep或者Blocked的不执行状态
>
> 可认为是`延伸`的安全点

#### 记忆集和卡表

> 记忆集：解决对象`跨代`引用问题
>
> 卡表是记忆集的一种实现方式

卡页：卡表（数组）对应的内存区域，如果对象存在跨代，就把数组元素的值标为1，GC扫描的时候跟GC Roots一并扫描。

#### 写屏障

> 解决卡表维护问题：区别JMM的写屏障，这个功能类似于AOP，为赋值操作生成对应的卡表操作指令

#### 可达性算法标记方式

三色标记：

1. 白色：尚未被回收器访问，结束仍为白色表示不可达
2. 黑色：所有引用都被扫描过，它是安全存活的
3. 灰色：对象被回收器访问过，但是至少还有一个引用没被扫描过

**并发标记产生的问题：**

原本应该回收的对象变存活：下次扫描清理即可

原本存活的对象被回收：分为以下两种情况

<img src="jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20210203192247516.png" alt="image-20210203192247516" style="zoom:50%;" />

1. `新插入`白色对象被之前扫描过的黑色对象引用，导致不在扫描被回收

   > 解决方式：`增量更新`，黑色对象指向白色对象的引用，则黑色对象变为`灰色`对象，重新扫描一次（黑->灰）
   >
   > 实现的回收器：CMS

<img src="jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20210203192345453.png" alt="image-20210203192345453" style="zoom:50%;" />

2. `引用链断开`，黑色对象不再扫描，导致引用对象被回收

   > 解决方式：`原始快照`，不管链路删除，扫描都从开始扫描对象的那一刻快照开始
   >
   > 实现的回收器：G1、Shenandoah

---



## 垃圾回收器

![image-20200819111350738](jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20200819111350738-2352515.png)

### 新生代

新生代收集器回收算法都是`复制回收算法`

#### Serial收集器

> 虚拟机分为客户端模式和服务端模式

Serial为`客户端模式`默认收集器：没有线程交互损耗，简单高效

#### ParNew收集器

> 优势：能和`CMS搭配`的新生代并行回收的收集器

**控制参数：**

1. -XX:+/-UseParNewGC 使用该收集器

#### Parallel Scavenge收集器

> jdk1.8默认回收器，搭配Paralle Old使用。有`自适应调节机制`

**同ParNew一样的并行回收器**：区别在于Parallel Scavenge关注吞吐量，ParNew关注停顿时间

<img src="jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20210221171844597.png" alt="image-20210221171844597" style="zoom:50%;" />

**控制参数：**

合理控制收集时间，时间短，收集次数则多。需要均衡`空间`和`时间`的代价

1. -XX:MaxGCPauseMilli：最大收集时间
2. -XX:GCTimeRatio：吞吐量大小
3. `+UseAdaptiveSizePolicy`：GC自适应调节策略，新生代大小等参数虚拟机动态调整

### 老年代

#### Serial Old收集器

> `单线程`收集器，采用`标记-整理算法`，可作为CMS失败的后选方案

#### Parallel Old收集器

> `多线程并行收集器`，采用`标记-整理算法`，搭配Parallel Scavenge使用

#### CMS收集器

<img src="jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20210222094352770.png" alt="image-20210222094352770" style="zoom:50%;" />

> `多线程并发并行收集器`，采用`标记-清除算法`，低停顿

**整个过程主要分为四个步骤：**

1. 初始标记（STW）：标记GC Roots直接关联对象，速度很快
2. 并发标记：从GC Roots直接关联对象开始遍历，和用户线程并发
3. 重新标记（STW）：并发标记过程用户线程变动的对象
4. 并发清除：删除标记死亡的对象



**缺点：**

1. 降低吞吐量：占用部分`线程`用于标记

2. 空间碎片
   - -XX:+UseCMS-CompactAtFullCollection：GC后就开始合并整理
   - -XX:CM SFullGCsBefore- Compaction：GC一定次数后开始整理

3. 产生浮动垃圾：并发清理过程中，用户线程产生的`浮动垃圾`可能出发另一次Full GC导致回收失败

   - 调高老年代触发GC的空间比例：

   -XX:CMSInitiatingOccu-pancyFraction

   > 注：调调高容易导致预留空间不足以分配新对象导致并发直白，采用Serial Old进行回收，停顿时间很长

---



#### G1收集器

<img src="jvm%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/image-20210222154107208.png" alt="image-20210222154107208" style="zoom:50%;" />

**整个过程主要分为四个步骤：**（区分CMS的步骤）

1. 初始标记（STW）：标记GC Roots直接关联对象，速度很快
2. 并发标记：从GC Roots直接关联对象开始遍历，和用户线程并发
3. 最终标记（STW）：并发标记过程用户线程变动的对象
4. 筛选回收（STW）

> 标记整理算法，收集不按照区域划分，将整个堆划分成多个region

- CMS对比G1:看应用场景

1. 小内存适合CMS，`6G`以上适合用G1
2. 回收算法不同
3. 用户进程运行过程中，G1额外执行负载要高
4. G1需要额外空间存储跨region引用

**调优参数：**

1. 控制region大小参数：-XX:G1Heap RegionSize，范围在`1～32M`
2. 参数-XX:MaxGCPauseMillis指定用户收集允许停顿时间，默认`200ml`，主要是通过`筛选回收`来实现

**缺点**：

1. 额外空间：需要耗费堆的10%～20%的内存用于维护跨region引用关系

#### Shenandoah收集器

#### ZGC收集器

> G1的升级，采用染色指针技术：将引用对象的信息存储在对象的指针上

容量（region）类型：小（2M）、中（32M）、大（动态变化）

### 如何选择收集器

1. jdk版本号限制
2. 操作系统限制：如ZGC无法在windows上运行。而shenandoah可以
3. 内存大小：CMS和G1的选择，根据内存大小选择，大于6GB选择G1，因为G1需要额外空间存储引用关系

### 常用参数

1. 打印GC日志：-XX:+PrintGCDetails

2. eden区和s区的比例：-XX:Survivor-Ratio

3. 进入老年代大对象阈值（只支持`Serial`和`ParNew`收集器）：

   -XX:PretenureSizeThreshold

4. s区age：-XX:MaxTenuringThreshold，如果在Survivor空间中`相同年龄`所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

#### 空间分配担保

老年代最大连续空间是否大于`历次`晋升到老年代的平均大小，若大于，触发minorGC并担保s区无法容纳的对象。



